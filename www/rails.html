<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
  <script src="lib/jquery-ui.min.js"></script>
  <link href="lib/jquery.tocify.css" rel="stylesheet"></link>
  <script src="lib/jquery.tocify.js"></script>
  <link href="handbook.css" rel="stylesheet"></link>

</head>
<body>

<div id="toc"></div>

<div class="main-column">
  <h1>Ruby on Rails</h1><h2>Setup</h2><h3>Set up repo</h3><pre><code>rails new app_name # optional: --database=postgresql
cd app_name
git init
git remote add origin &lt;SSH address&gt;
git push -u origin master
</code></pre><h3>Create a model</h3><pre><code>rails g model Post title:string body:string
// Examine the new migration and make any required changes
rails db:migrate
</code></pre><h3>Create routes</h3><pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  root &quot;posts#index&quot;
  resources :posts
end
</code></pre>
<p>Check your routes with <code>rails routes</code>.</p>
<p>Other things you can do in routes.rb:</p>
<pre><code class="language-ruby">resources :posts, :only =&gt; [:index, :show]
resources :posts, :except =&gt; [:index]

get &#39;/presents/:id/deliver/:receiver&#39; =&gt; &#39;presents#deliver&#39;
# in presents#deliver, look at params[:id] and params[:receiver]
</code></pre>
<h3>Create controller</h3><pre><code>rails g controller posts
</code></pre><pre><code class="language-ruby"># app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController

  def index
    @posts = Post.all
  end

  def new
    @post = Post.new
  end

  def create
    @post = Post.new(strong_params)
    if @post.save
      # Woohoo
      redirect_to @post
    else
      # boohoo
      render :new
    end
  end

  def show
    @post = Post.find(params[:id])
  end

  def edit
    @post = Post.find(params[:id])
  end

  def update
    @post = Post.find(params[:id])
    if @post.update(strong_params)
      redirect_to @post
    else
      render :edit
    end
  end

  def destroy
    Post.find(params[:id]).destroy!
    redirect_to posts_path
  end

  private
  def strong_params
    params.require(:post).permit(:title,:body,:author_id)
  end

end
</code></pre>
<h3>Create view</h3><pre><code># app/views/posts/index.html.erb
&lt;h1&gt;
  Posts
&lt;/h1&gt;
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;
    &lt;%= post.title %&gt;
  &lt;/h2&gt;
  &lt;p&gt;
    &lt;%= post.body %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre><h3>Better Errors</h3><pre><code>// Gemfile
group :development do
  gem &quot;better_errors&quot;
  gem &quot;binding_of_caller&quot;
  gem &quot;jazz_fingers&quot;
end
</code></pre><h3>Add Bootstrap</h3><pre><code class="language-javascript">// app/assets/javascripts/application.js

//= require bootstrap-sprockets
</code></pre>
<pre><code>// Gemfile
gem &#39;bootstrap-sass&#39;
</code></pre><pre><code>/* app/assets/stylesheets/global.scss */
@import &#39;bootstrap-sprockets&#39;;
@import &#39;bootstrap&#39;;
</code></pre><h3>Create Postgres database</h3><p>Add &quot;pg&quot; to your Gemfile.</p>
<p>In config/database.yml, under &quot;default&quot;, change &quot;adapter&quot; to &quot;postgresql&quot;. Under &quot;development&quot;, change &quot;database&quot; to &quot;devise_development&quot;, under &quot;test&quot; change it to &quot;devise_test&quot;, and under &quot;production&quot; change it to &quot;devise_production&quot;.</p>
<p>Then run <code>rails db:create</code>.</p>
<h2>The Flash <img src="img/Flash.png" alt="The Flash"></h2><pre><code class="language-ruby"># app/controllers/posts_controller.rb
def create
  @post = Post.new(params[:post])
  if @post.save
    flash[:success] = &quot;Great! Your post has been created!&quot;
    redirect_to @post # go to show page for @post
  else
    flash.now[:error] = &quot;Rats! Fix your mistakes, please.&quot;
    render :new
  end
end
</code></pre>
<h2>Links</h2><pre><code>&lt;%= link_to &quot;See All Users&quot;, users_path %&gt; #=&gt; &lt;a href=&quot;/users&quot;&gt;See All Users&lt;/a&gt;

&lt;%= link_to &quot;See user&quot;, user_path(user.id) %&gt; #= &lt;a href=&quot;/user/1&quot;&gt;See user&lt;/a&gt;

&lt;%= button_to &quot;Edit user&quot;, edit_user_path(user.id) %&gt; #= &lt;a href=&quot;/user/1&quot;&gt;See user&lt;/a&gt;

&lt;%= link_to &quot;Destroy user&quot;, user_path(user.id), method: :delete %&gt;
</code></pre><p>Note that in <code>rails routes</code>, <code>edit_user</code> is listed in the Prefix column, so the link is <code>edit_user_path</code>. The DELETE verb doesn&#39;t have its own prefix; you just use the user&#39;s link with the <code>:delete</code> method.</p>
<h2>Forms</h2><p><a href="http://stackoverflow.com/documentation/html/277/input-control-elements/2259/input-validation#t=201612081944357410854">HTML5 Form Input Validation</a> on StackOverflow Documentation</p>
<h3>Simple</h3><pre><code>&lt;%= form_tag(&quot;/search&quot;, method: &quot;get&quot;) do %&gt;
  &lt;%= label_tag(:query, &quot;Search for:&quot;) %&gt;
  &lt;%= text_field_tag(:query) %&gt;
  &lt;%= submit_tag(&quot;Search&quot;) %&gt;
&lt;% end %&gt;
</code></pre><h3>Automated</h3><pre><code># app/controllers/articles_controller.rb
def new
  @article = Article.new
end

#app/views/articles/new.html.erb
&lt;%= form_for @article do |form| %&gt;
  &lt;%= form.label :title %&gt;
  &lt;%= form.text_field :title %&gt;
  &lt;%= form.text_area :body, size: &quot;60x12&quot; %&gt;
  &lt;%= form.submit &quot;Create&quot; %&gt;
&lt;% end %&gt;
</code></pre><p>Options go inside a hash. HTML options go inside their own sub-hash.</p>
<pre><code>&lt;%= form_for @post, {:html =&gt; { :class =&gt; &quot;your_class&quot; } } do |f| %&gt;
</code></pre><p>All forms created with Rails helpers will automatically include hidden <code>&lt;input&gt;</code>s for encoding and Rails&#39; required authenticity token.</p>
<h3>Nested</h3><p>Model:</p>
<pre><code class="language-ruby"># app/models/product.rb
class Product &lt; ActiveRecord::Base
  has_many :category_placements
  has_many :categories, :through =&gt; :category_placements

  has_many :reviews

  accepts_nested_attributes_for :reviews,
                                :reject_if =&gt; :all_blank,
                                :allow_destroy =&gt; true;
end

# app/models/review.rb
class Review &lt; ActiveRecord::Base
  belongs_to :product
end
</code></pre>
<p>View:</p>
<pre><code>&lt;%= form_for @product do |product_fields| %&gt;

  &lt;%= product_fields.label :name %&gt;
  &lt;%= product_fields.text_field :name %&gt;
  ...

  &lt;%= product_fields.fields_for :reviews do |review_fields| %&gt;
    &lt;%= review_fields.label :title %&gt;
    &lt;%= review_fields.text_field :title %&gt;

    # checkbox to destroy the object
    &lt;% if review_fields.object.persisted? %&gt;
      &lt;%= review_fields.label :_destroy, &quot;Delete this review?&quot; %&gt;
      &lt;%= review_fields.check_box :_destroy %&gt;
    &lt;% end %&gt;

  &lt;%= product_fields.submit &quot;Create&quot; %&gt;

  &lt;% end %&gt;
</code></pre><p>Controller:</p>
<pre><code class="language-ruby">def edit
  @product = Product.find(params[:id])
  # build an extra empty review on the association
  @product.reviews.build
end

def whitelisted_params
  params.require(:product).permit(:name, :reviews_attributes =&gt; [:title, :id, :_destroy ])
end
</code></pre>
<p><em><a href="https://www.vikingcodeschool.com/dashboard#/advanced-forms-and-active-record/a-simple-nested-form">Source</a></em></p>
<h2>Validation</h2><pre><code class="language-ruby"># app/models/post.rb
class Post &lt; ActiveRecord::Base
  validates :title, :body, :subheading
              :presence =&gt; true, # Does it have content?
              :uniqueness =&gt; true,
              :length =&gt;{ :maximum =&gt; 40,
                          :minimum =&gt; 10,
                          :in =&gt; 10..40, # same as above
                          :is =&gt; 16 },
              :inclusion =&gt; [ &quot;Team Leader&quot;,
                              &quot;Class President&quot;,
                              &quot;Student&quot; ],
              :format =&gt; { :with =&gt; /@/ },
              :on =&gt; :create,
              :strict =&gt; true,
              :message =&gt; &quot;didn&#39;t work!&quot;,
              :if =&gt; :some_method_returns_true,
              :unless =&gt; Proc.new{ self.registered }
end
</code></pre>
<pre><code class="language-ruby">p = Post.new
p.title = &quot;short title&quot;
p.valid? #=&gt; true
p.title = &quot;very super duper long title&quot;
p.valid? #=&gt; false
p.errors[:title] #=&gt; [&quot;is too long (maximum is 20 characters)&quot;]
p.errors.full_messages #=&gt; [&quot;Title is too long (maximum is 20 characters)&quot;]
</code></pre>
<h2>Relations</h2><p>ActiveRecord objects provide an object-oriented interface to the SQL database. When you use a command like <code>Post.where(:published =&gt; true)</code>, it returns a <strong>relation</strong>. Relations can be comboed together, somewhat like chaining in jQuery, but the SQL query doesn&#39;t get run until you use a combo breaker that actually returns a value, like <code>each</code>, <code>all</code>, <code>to_a</code>, <code>inspect</code>, etc.</p>
<h2>Associations</h2><p>You can inform Rails about a relationship between models like so:</p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ActiveRecord::Base
  has_many :posts
end

# app/models/post.rb
class Post &lt; ActiveRecord:Base
  belongs_to :user
end
</code></pre>
<p>If you do that, Rails will write a lot of SQL for you, allowing you to do things like this:</p>
<pre><code class="language-ruby"># Assume
u = User.first
p = Post.first

# All Posts written by the User
u.posts

# Build a Post with that User set as the Author
u.posts.build

# Traverse the relationship the opposite way,
# retrieving the Author of that post
p.user
</code></pre>
<p>Don&#39;t forget to specify the relationship from both directions.</p>
<p>Renaming a relationship:</p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  has_many :users, foreign_key: :author_id
end

class Comment &lt; ApplicationRecord
  belongs_to :post
end

# generate a migration with rails g migration RenameUserIdToAuthorIdInComments
class RenameUserIdToAuthorIdInComments &lt; ActiveRecord::Migration[5.0]
  def change
    rename_column :comments, :user_id, :author_id
  end
end
</code></pre>
<h3>Many-to-many relationship</h3><p>Generating the model:</p>
<pre><code class="language-bash">rails g model Programmer name:string
rails g model Client name:string
rails g model Project programmer:references client:references
rake db:migrate
</code></pre>
<p>&quot;The <code>:references</code> syntax is a shortcut for creating an index on the preceding field name, programmer and client in this instance, as well as marking them as foreign key constraints for the programmers and clients database tables.&quot; <em><a href="http://joshfrankel.me/blog/2016/how-to/create-a-many-to-many-activerecord-association-in-ruby-on-rails/">source</a></em></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :user_posts
  has_many :posts, through: :user_posts
end

class Post &lt; ApplicationRecord
  has_many :user_posts
  has_many :users, through: :user_posts
end

class UserPost &lt; ApplicationRecord
  belongs_to :post
  belongs_to :user
end
</code></pre>
<p>Making use of relationships:</p>
<pre><code class="language-ruby">bob = User.create
alpha = bob.posts.create
bob.posts #=&gt; alpha

post1 = Post.create
tag1 = Tag.create
post_tag = PostTag.create(post: post1, tag: tag1)
post1.tags #=&gt; tag1
</code></pre>
<h4>Rename a many-to-many relationship</h4><pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :user_posts
  has_many :posts, through: :user_posts
end

class Post &lt; ApplicationRecord
  has_many :user_posts, foreign_key: :post_id
  has_many :authors, through: :user_posts, source: :user
end

class UserPost &lt; ApplicationRecord
  belongs_to :post
  belongs_to :user
end
</code></pre>
<pre><code class="language-bash">rails db:migrate
rails g migration AddAssociationColumnOrSomething
</code></pre>
<pre><code class="language-ruby">class AddAssociationColumn &lt; ActiveRecord::Migration[5.0]
  def change
    add_column :user_posts, :user_id, :integer
    add_column :user_posts, :post_id, :integer
    add_index :user_posts, [:user_id, :post_id], unique: true
  end
end
</code></pre>
<h4>Self-referencing associations</h4><pre><code>rails g model StarFighter ship_class:string call_sign:string
rails g model DogFights attacker_id:integer attacked_id:integer
</code></pre><pre><code class="language-ruby"># app/models/star_fighter.rb
class StarFighter &lt; ApplicationRecord

  has_many :outgoing_fire, foreign_key: :attacker_id, class_name: &quot;DogFight&quot;
  has_many :attacked, :through =&gt; :outgoing_fire

  has_many :incoming_fire, foreign_key: :attacked_id, class_name: &quot;DogFight&quot;
  has_many :attackers, :through =&gt; :incoming_fire

end

# app/models/dog_fight.rb
class DogFight &lt; ApplicationRecord

  belongs_to :attacker, :foreign_key =&gt; :attacker_id, :class_name =&gt; &quot;StarFighter&quot;
  belongs_to :attacked, :foreign_key =&gt; :attacked_id, :class_name =&gt; &quot;StarFighter&quot;
  validates :attacked_id, :uniqueness =&gt; { :scope =&gt; :attacker_id }

end
</code></pre>
<h3>Renaming</h3><pre><code class="language-ruby">belongs_to :author, :class_name =&gt; &quot;User&quot; # Rename the model
belongs_to :user, :foreign_key =&gt; :author_id # Rename the foreign key
has_many :tagged_posts, :through =&gt; :post_taggings, :source =&gt; :post # Rename the relationship

belongs_to :category, optional: true
</code></pre>
<h3>Other options</h3><pre><code class="language-ruby">belongs_to :category, optional: true
</code></pre>
<h2>Orphans</h2><p>If a user has many posts, and you a <code>destroy</code> a user, all their posts are orphans. They point to a user that no longer exists, which is bad. If you <code>delete</code> a post, all IDs pointing to it are set to nil, which also isn&#39;t great. It&#39;s best to set up links to prevent this:</p>
<pre><code class="language-ruby">has_many :posts, :dependent =&gt; :destroy # If I die, my children go with me!
</code></pre>
<h2>Callbacks</h2><pre><code class="language-ruby"># Be welcoming with an after_create callback
after_create :send_welcome_email, :unless =&gt; :method_is_true
# ... and be sure to write the method to support it
private
def send_welcome_email
  # ...code to send the email
end
def method_is_true
  # code code code
end

# Get around the destroy
around_destroy :log_status
private
# ...and the method to support it:
def log_status
  puts &quot;About to destroy Post with ID:#{self.id}&quot;
  yield
  puts &quot;Successfully destroyed Post with ID:#{self.id}&quot;
end

# Using a block instead of a full method
before_save { |p| p.published_time = Time.now }
</code></pre>
<h2>Useful methods</h2><pre><code class="language-ruby">&quot;User&quot;.pluralize #=&gt; &quot;Users&quot;
pluralize(3,&quot;user&quot;) #=&gt; &quot;3 users&quot;
</code></pre>
<p>If the database is refusing to commit your transactions and you&#39;re not sure why, run <code>.errors.full_messages</code> on your object.</p>
<p>Put this in your controller to run something before each action:</p>
<pre><code class="language-ruby">before_action :find_post, only: [:edit, :show, :update]
</code></pre>
</div>

<script>
hljs.initHighlightingOnLoad(); // syntax highlighting

jQuery(document).ready(function() {
  if (jQuery(window).height() < jQuery(document).height()) {
    $('#toc').tocify({
      extendPage: false
    });
  }
});
</script>


</body>
