<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
</head>
<body>

<div class="container">
  <div class="row">
    <div class="col-sm-12">
      <h1>Ruby on Rails</h1><h2>Relations</h2><p>ActiveRecord objects provide an object-oriented interface to the SQL database. When you use a command like <code>Post.where(:published =&gt; true)</code>, it returns a <strong>relation</strong>. Relations can be comboed together, somewhat like chaining in jQuery, but the SQL query doesn&#39;t get run until you use a combo breaker that actually returns a value, like <code>each</code>, <code>all</code>, <code>to_a</code>, <code>inspect</code>, etc.</p>
<h2>Associations</h2><p>You can inform Rails about a relationship between models like so:</p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ActiveRecord::Base
  has_many :posts
end

# app/models/post.rb
class Post &lt; ActiveRecord:Base
  belongs_to :user
end
</code></pre>
<p>If you do that, Rails will write a lot of SQL for you, allowing you to do things like this:</p>
<pre><code class="language-ruby"># Assume
u = User.first
p = Post.first

# All Posts written by the User
u.posts

# Build a Post with that User set as the Author
u.posts.build

# Traverse the relationship the opposite way,
# retrieving the Author of that post
p.user
</code></pre>
<p>Don&#39;t forget to specify the relationship from both directions.</p>
<h3>Many-to-many relationship:</h3><pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :user_posts
  has_many :posts, through: :user_posts
end

class Post &lt; ApplicationRecord
  has_many :user_posts
  has_many :users, through: :user_posts
end

class UserPost &lt; ApplicationRecord
  belongs_to :post
  belongs_to :user
end
</code></pre>
<h3>Rename a many-to-many relationship:</h3><pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :user_posts
  has_many :posts, through: :user_posts
end

class Post &lt; ApplicationRecord
  has_many :user_posts, foreign_key: :post_id
  has_many :authors, through: :user_posts, source: :user
end

class UserPost &lt; ApplicationRecord
  belongs_to :post
  belongs_to :user
end
</code></pre>
<pre><code class="language-bash">rails db:migrate
rails g migration AddAssociationColumnOrSomething
</code></pre>
<pre><code class="language-ruby">class AddAssociationColumn &lt; ActiveRecord::Migration[5.0]
  def change
    add_column :user_posts, :user_id, :integer
    add_column :user_posts, :post_id, :integer
    add_index :user_posts, [:user_id, :post_id], unique: true
  end
end
</code></pre>
<h3>More options:</h3><pre><code class="language-ruby">belongs_to :author, :class_name =&gt; &quot;User&quot; # When you need to rename the relationship. Note the use of a string instead of a symbol.
belongs_to :user, :foreign_key =&gt; :author_id # Rename the foreign key
belongs_to :category, optional: true

# if you rename the association for a X:X
# tell Rails how to traverse the join table now
class Tag &lt; ActiveRecord::Base
  has_many  :tagged_posts,  :through =&gt; :post_taggings,
                            :source =&gt; :post
end
</code></pre>
<p>Generating the model for a many-to-many relationship:</p>
<pre><code class="language-bash">rails g model Programmer name:string
rails g model Client name:string
rails g model Project programmer:references client:references
rake db:migrate
</code></pre>
<p>&quot;The <code>:references</code> syntax is a shortcut for creating an index on the preceding field name, programmer and client in this instance, as well as marking them as foreign key constraints for the programmers and clients database tables.&quot; <em><a href="http://joshfrankel.me/blog/2016/how-to/create-a-many-to-many-activerecord-association-in-ruby-on-rails/">source</a></em></p>
<pre><code class="language-ruby">bob = User.create
alpha = bob.posts.create
bob.posts #=&gt; alpha
</code></pre>
<h2>Orphans</h2><p>If a user has many posts, and you a <code>destroy</code> a user, all their posts are orphans. They point to a user that no longer exists, which is bad. If you <code>delete</code> a post, all IDs pointing to it are set to nil, which also isn&#39;t great. It&#39;s best to set up links to prevent this:</p>
<pre><code class="language-ruby">has_many :posts, :dependent =&gt; :destroy # If I die, my children go with me!
</code></pre>
<h2>Callbacks</h2><pre><code class="language-ruby"># Be welcoming with an after_create callback
after_create :send_welcome_email, :unless =&gt; :method_is_true
# ... and be sure to write the method to support it
private
def send_welcome_email
  # ...code to send the email
end
def method_is_true
  # code code code
end

# Get around the destroy
around_destroy :log_status
private
# ...and the method to support it:
def log_status
  puts &quot;About to destroy Post with ID:#{self.id}&quot;
  yield
  puts &quot;Successfully destroyed Post with ID:#{self.id}&quot;
end

# Using a block instead of a full method
before_save { |p| p.published_time = Time.now }
</code></pre>
<h2>Useful methods</h2><pre><code class="language-ruby">&quot;User&quot;.pluralize #=&gt; &quot;Users&quot;
pluralize(3,&quot;user&quot;) #=&gt; &quot;3 users&quot;
</code></pre>
<p>If the database is refusing to commit your transactions and you&#39;re not sure why, run <code>.errors.full_messages</code> on your object.</p>
    </div>
  </div>
</div>

<script>
hljs.initHighlightingOnLoad(); // syntax highlighting
</script>


</body>
