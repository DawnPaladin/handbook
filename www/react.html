<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Handbook</title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="lib/jquery-ui.min.js"></script>
  <link href="lib/jquery.tocify.css" rel="stylesheet"></link>
  <script src="lib/jquery.tocify.js"></script>
  <script src="lib/prism.js"></script>
  <link rel="stylesheet" href="lib/prism.css"/>
  <link href="handbook.css" rel="stylesheet"></link>
  <link href="blueprint.css" rel="stylesheet"></link>

</head>
<body>

<div id="toc">
  <a href="index.html" class="index-link">Index</a>
</div>

<div class="main-column">
  <p><strong>React</strong></p>
<h1>Basics</h1><pre><code class="language-jsx">const jsx = &lt;h1&gt;Hello, world!&lt;/h1&gt;
ReactDOM.render(jsx, document.getElementById(&#39;root&#39;));
{/* this is what comments look like */}</code></pre>
<h1>Components</h1><p>Custom components must have their names start with a capital letter.</p>
<p><code>class</code> is a reserved word in JavaScript, so JSX uses <code>className</code>.</p>
<h2>Stateless functional component</h2><pre><code class="language-jsx">const MyComponent = function() {
    return {
        &lt;div className=&#39;nameOfTheClass&#39; /&gt;
    }
}</code></pre>
<p>Or, more simply:</p>
<pre><code class="language-jsx">const MyComponent = props =&gt; (&lt;div&gt;Name: {props.name}&lt;/div&gt;);

&lt;MyComponent name=&quot;Joe&quot; /&gt;</code></pre>
<h2>Stateless component</h2><pre><code class="language-jsx">class Kitten extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            &lt;h1&gt;Hi&lt;/h1&gt;
        );
    }
}

&lt;Kitten /&gt;</code></pre>
<h2>Props</h2><p>Passing a prop (property) into a component:</p>
<pre><code class="language-jsx">&lt;Cat type=&quot;kitten&quot; /&gt;

const Cat = (props) =&gt; &lt;div&gt;This cat is a {props.type}&lt;/div&gt;</code></pre>
<h3>Default props</h3><pre><code class="language-jsx">Cat.defaultProps = { name: &quot;DefaultCat&quot; };</code></pre>
<h3>Setting prop types</h3><pre><code class="language-jsx">Cat.propTypes = { name: PropTypes.string };</code></pre>
<p>PropTypes are the same as JavaScript types, except for <code>func</code> and <code>bool</code>.</p>
<p>To make the prop <strong>required:</strong></p>
<pre><code class="language-jsx">Cat.propTypes = { name: PropTypes.string.isRequired };</code></pre>
<h2>State</h2><h3>Declaring state</h3><pre><code class="language-jsx">class Cat extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: &quot;Fluffle&quot; };
    }
    render() {
        return (
          &lt;p&gt;I am a cat named {this.state.name}&lt;/p&gt;
        )
    }
}</code></pre>
<h3>Updating state</h3><pre><code class="language-jsx">this.setState({ name: &quot;Grumpy Cat&quot; });</code></pre>
<h2>Methods</h2><p>Methods typically need access to <code>this</code>, which is provided by <code>bind</code>ing it in the constructor.</p>
<pre><code class="language-jsx">class Cat extends React.component {
    constructor(props) {
        super(props);
        this.state = { foodLevel: 0 };
        this.eat = this.eat.bind(this);
    }
    eat() {
        this.setState({
            foodLevel: this.state.foodLevel + 1;
        });
    }
    render() {
        return (
            &lt;div&gt;
                &lt;button onClick={this.eat}&gt;Eat&lt;/button&gt;
                &lt;p&gt;Food level: {this.state.foodLevel}&lt;/p&gt;
            &lt;/div&gt;
        );
    }
}</code></pre>
<h2>Controlled Inputs</h2><p>You can set up components that have two-way data binding between the DOM state and the React component&#39;s state.</p>
<pre><code class="language-jsx">class Cat extends React.component {
    constructor(props) {
        super(props);
        this.state = { thoughts: &#39;&#39; };
        this.handleChange = this.handleChange.bind(this);
    }
    handleChange(event) {
        this.setState({ input: event.target.value });
    }
    render() {
        return (
            &lt;div&gt;
                &lt;label&gt;Enter thoughts &lt;input value={this.state.thoughts} onChange={this.handleChange} /&gt; &lt;/label&gt;
                &lt;p&gt;Thoughts: {this.state.thoughts}&lt;/p&gt;
            &lt;/div&gt;
        );
    }
}</code></pre>
<p>This can be done with whole <code>&lt;form&gt;</code> elements.</p>
<pre><code class="language-jsx">&lt;form onSubmit={this.handleSubmit}&gt;
    &lt;button type=&#39;submit&#39;&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
<p>Don&#39;t forget to include an <code>event.preventDefault()</code> statement in the submit handler; actually submitting the form would cause a page refresh.</p>
<h1>Styling</h1><pre><code class="language-jsx">&lt;div style={{
    color: &#39;red&#39;,
    height: 100, // defaults to px
    width: &quot;50%&quot; // but you can specify other units
}}&gt;</code></pre>
<h1>Conditional rendering</h1><h2>&amp;&amp; operator</h2><p>You can perform traditional JavaScript logic to determine what JSX a <code>render()</code> function should return. This can be made more concise using the <code>&amp;&amp;</code> logical operator:</p>
<pre><code class="language-jsx">return (
    &lt;p&gt;Always display&lt;/p&gt;
    { this.state.displaySecondPara &amp;&amp; &lt;p&gt;Sometimes display&lt;/p&gt; }
)</code></pre>
<p>If the condition is false, the logic will short-circuit out the JSX.</p>
<h2>Ternary operator</h2><pre><code class="language-jsx">render() {
    const JSXifTrue = &lt;div/&gt;
    const JSXifFalse = &lt;p/&gt;
    return (
        { condition ? JSXifTrue : JSXifFalse }
    );
}</code></pre>
</div>

<script>
jQuery(document).ready(function() {
  if (jQuery(window).height() < jQuery(document).height()) {
    $('#toc').tocify({
      extendPage: false
    });
  }
});
</script>

</body>
